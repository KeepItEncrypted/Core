/* tslint:disable */
/* eslint-disable */
/**
 * SecureTransferBackend
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ApiTransfersBundleBundleIdAddFilePostRequest
 */
export interface ApiTransfersBundleBundleIdAddFilePostRequest {
    /**
     * 
     * @type {File}
     * @memberof ApiTransfersBundleBundleIdAddFilePostRequest
     */
    'FormFile': File;
    /**
     * 
     * @type {string}
     * @memberof ApiTransfersBundleBundleIdAddFilePostRequest
     */
    'EncryptedFileName': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTransfersBundleBundleIdAddFilePostRequest
     */
    'Signature': string;
}
/**
 * 
 * @export
 * @interface ApiTransfersPostRequest
 */
export interface ApiTransfersPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiTransfersPostRequest
     */
    'UserId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTransfersPostRequest
     */
    'UsedPublicKeyId': string;
    /**
     * 
     * @type {Array<EncryptedFileDto>}
     * @memberof ApiTransfersPostRequest
     */
    'EncryptedFiles': Array<EncryptedFileDto>;
    /**
     * 
     * @type {Array<EncryptedKeyDto>}
     * @memberof ApiTransfersPostRequest
     */
    'EncryptedKeys': Array<EncryptedKeyDto>;
}
/**
 * 
 * @export
 * @interface AttachmentDto
 */
export interface AttachmentDto {
    /**
     * 
     * @type {string}
     * @memberof AttachmentDto
     */
    'fileName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttachmentDto
     */
    'storageLocation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AttachmentDto
     */
    'signature'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateBundle
 */
export interface CreateBundle {
    /**
     * 
     * @type {string}
     * @memberof CreateBundle
     */
    'encryptedMessage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateBundle
     */
    'usedPublicKeyId': string;
    /**
     * 
     * @type {Array<CreateRecipient>}
     * @memberof CreateBundle
     */
    'recipients': Array<CreateRecipient>;
}
/**
 * 
 * @export
 * @interface CreatePublicKeyPair
 */
export interface CreatePublicKeyPair {
    /**
     * 
     * @type {string}
     * @memberof CreatePublicKeyPair
     */
    'publicVerifierKey': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePublicKeyPair
     */
    'publicEncryptionKey': string;
}
/**
 * 
 * @export
 * @interface CreateRecipient
 */
export interface CreateRecipient {
    /**
     * 
     * @type {string}
     * @memberof CreateRecipient
     */
    'userId'?: string;
    /**
     * 
     * @type {Array<EncryptedKeyDto>}
     * @memberof CreateRecipient
     */
    'encryptedKeys'?: Array<EncryptedKeyDto> | null;
}
/**
 * 
 * @export
 * @interface CreatedBundle
 */
export interface CreatedBundle {
    /**
     * 
     * @type {string}
     * @memberof CreatedBundle
     */
    'createdBundleId'?: string;
}
/**
 * 
 * @export
 * @interface DecryptorKeyDto
 */
export interface DecryptorKeyDto {
    /**
     * 
     * @type {string}
     * @memberof DecryptorKeyDto
     */
    'encryptedSymmetricKey'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DecryptorKeyDto
     */
    'publicKeyUsedForEncryption'?: string | null;
}
/**
 * 
 * @export
 * @interface EncryptedFileDto
 */
export interface EncryptedFileDto {
    /**
     * 
     * @type {File}
     * @memberof EncryptedFileDto
     */
    'formFile': File;
    /**
     * 
     * @type {string}
     * @memberof EncryptedFileDto
     */
    'encryptedFileName': string;
    /**
     * 
     * @type {string}
     * @memberof EncryptedFileDto
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface EncryptedKeyDto
 */
export interface EncryptedKeyDto {
    /**
     * 
     * @type {string}
     * @memberof EncryptedKeyDto
     */
    'publicKeyPairId': string;
    /**
     * 
     * @type {string}
     * @memberof EncryptedKeyDto
     */
    'encryptedAesKey': string;
}
/**
 * 
 * @export
 * @interface InboxItem
 */
export interface InboxItem {
    /**
     * 
     * @type {string}
     * @memberof InboxItem
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InboxItem
     */
    'bundleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InboxItem
     */
    'message'?: string | null;
}
/**
 * 
 * @export
 * @interface InboxItemDetail
 */
export interface InboxItemDetail {
    /**
     * 
     * @type {string}
     * @memberof InboxItemDetail
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InboxItemDetail
     */
    'bundleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InboxItemDetail
     */
    'publicKeyIdForSignature'?: string;
    /**
     * 
     * @type {string}
     * @memberof InboxItemDetail
     */
    'message'?: string | null;
    /**
     * 
     * @type {Array<AttachmentDto>}
     * @memberof InboxItemDetail
     */
    'attachments'?: Array<AttachmentDto> | null;
    /**
     * 
     * @type {Array<DecryptorKeyDto>}
     * @memberof InboxItemDetail
     */
    'decryptorKeys'?: Array<DecryptorKeyDto> | null;
}
/**
 * 
 * @export
 * @interface PublicKeyPairDto
 */
export interface PublicKeyPairDto {
    /**
     * 
     * @type {string}
     * @memberof PublicKeyPairDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyPairDto
     */
    'publicVerifierKey'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyPairDto
     */
    'publicEncryptionKey'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyPairDto
     */
    'applicationUserId'?: string;
}

/**
 * AntiforgeryApi - axios parameter creator
 * @export
 */
export const AntiforgeryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAntiforgeryTokenGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Antiforgery/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AntiforgeryApi - functional programming interface
 * @export
 */
export const AntiforgeryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AntiforgeryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAntiforgeryTokenGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAntiforgeryTokenGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AntiforgeryApi - factory interface
 * @export
 */
export const AntiforgeryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AntiforgeryApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAntiforgeryTokenGet(options?: any): AxiosPromise<void> {
            return localVarFp.apiAntiforgeryTokenGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AntiforgeryApi - object-oriented interface
 * @export
 * @class AntiforgeryApi
 * @extends {BaseAPI}
 */
export class AntiforgeryApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AntiforgeryApi
     */
    public apiAntiforgeryTokenGet(options?: AxiosRequestConfig) {
        return AntiforgeryApiFp(this.configuration).apiAntiforgeryTokenGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InboxApi - axios parameter creator
 * @export
 */
export const InboxApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInboxGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Inbox`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} recipientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInboxRecipientIdGet: async (recipientId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipientId' is not null or undefined
            assertParamExists('apiInboxRecipientIdGet', 'recipientId', recipientId)
            const localVarPath = `/api/Inbox/{recipientId}`
                .replace(`{${"recipientId"}}`, encodeURIComponent(String(recipientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InboxApi - functional programming interface
 * @export
 */
export const InboxApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InboxApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInboxGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InboxItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInboxGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} recipientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInboxRecipientIdGet(recipientId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InboxItemDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInboxRecipientIdGet(recipientId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InboxApi - factory interface
 * @export
 */
export const InboxApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InboxApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInboxGet(options?: any): AxiosPromise<Array<InboxItem>> {
            return localVarFp.apiInboxGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} recipientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInboxRecipientIdGet(recipientId: string, options?: any): AxiosPromise<InboxItemDetail> {
            return localVarFp.apiInboxRecipientIdGet(recipientId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InboxApi - object-oriented interface
 * @export
 * @class InboxApi
 * @extends {BaseAPI}
 */
export class InboxApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    public apiInboxGet(options?: AxiosRequestConfig) {
        return InboxApiFp(this.configuration).apiInboxGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} recipientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    public apiInboxRecipientIdGet(recipientId: string, options?: AxiosRequestConfig) {
        return InboxApiFp(this.configuration).apiInboxRecipientIdGet(recipientId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PublicKeyPairApi - axios parameter creator
 * @export
 */
export const PublicKeyPairApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPublicKeyPairForUserUserIdGet: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiPublicKeyPairForUserUserIdGet', 'userId', userId)
            const localVarPath = `/api/PublicKeyPair/for-user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPublicKeyPairGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/PublicKeyPair`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreatePublicKeyPair} [createPublicKeyPair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPublicKeyPairPost: async (createPublicKeyPair?: CreatePublicKeyPair, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/PublicKeyPair`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPublicKeyPair, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} publicKeyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPublicKeyPairPublicKeyIdGet: async (publicKeyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicKeyId' is not null or undefined
            assertParamExists('apiPublicKeyPairPublicKeyIdGet', 'publicKeyId', publicKeyId)
            const localVarPath = `/api/PublicKeyPair/{publicKeyId}`
                .replace(`{${"publicKeyId"}}`, encodeURIComponent(String(publicKeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicKeyPairApi - functional programming interface
 * @export
 */
export const PublicKeyPairApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicKeyPairApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPublicKeyPairForUserUserIdGet(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicKeyPairDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPublicKeyPairForUserUserIdGet(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPublicKeyPairGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicKeyPairDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPublicKeyPairGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreatePublicKeyPair} [createPublicKeyPair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPublicKeyPairPost(createPublicKeyPair?: CreatePublicKeyPair, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPublicKeyPairPost(createPublicKeyPair, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} publicKeyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPublicKeyPairPublicKeyIdGet(publicKeyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKeyPairDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPublicKeyPairPublicKeyIdGet(publicKeyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublicKeyPairApi - factory interface
 * @export
 */
export const PublicKeyPairApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicKeyPairApiFp(configuration)
    return {
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPublicKeyPairForUserUserIdGet(userId: string, options?: any): AxiosPromise<Array<PublicKeyPairDto>> {
            return localVarFp.apiPublicKeyPairForUserUserIdGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPublicKeyPairGet(options?: any): AxiosPromise<Array<PublicKeyPairDto>> {
            return localVarFp.apiPublicKeyPairGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreatePublicKeyPair} [createPublicKeyPair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPublicKeyPairPost(createPublicKeyPair?: CreatePublicKeyPair, options?: any): AxiosPromise<void> {
            return localVarFp.apiPublicKeyPairPost(createPublicKeyPair, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} publicKeyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPublicKeyPairPublicKeyIdGet(publicKeyId: string, options?: any): AxiosPromise<PublicKeyPairDto> {
            return localVarFp.apiPublicKeyPairPublicKeyIdGet(publicKeyId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublicKeyPairApi - object-oriented interface
 * @export
 * @class PublicKeyPairApi
 * @extends {BaseAPI}
 */
export class PublicKeyPairApi extends BaseAPI {
    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeyPairApi
     */
    public apiPublicKeyPairForUserUserIdGet(userId: string, options?: AxiosRequestConfig) {
        return PublicKeyPairApiFp(this.configuration).apiPublicKeyPairForUserUserIdGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeyPairApi
     */
    public apiPublicKeyPairGet(options?: AxiosRequestConfig) {
        return PublicKeyPairApiFp(this.configuration).apiPublicKeyPairGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreatePublicKeyPair} [createPublicKeyPair] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeyPairApi
     */
    public apiPublicKeyPairPost(createPublicKeyPair?: CreatePublicKeyPair, options?: AxiosRequestConfig) {
        return PublicKeyPairApiFp(this.configuration).apiPublicKeyPairPost(createPublicKeyPair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} publicKeyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeyPairApi
     */
    public apiPublicKeyPairPublicKeyIdGet(publicKeyId: string, options?: AxiosRequestConfig) {
        return PublicKeyPairApiFp(this.configuration).apiPublicKeyPairPublicKeyIdGet(publicKeyId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransfersApi - axios parameter creator
 * @export
 */
export const TransfersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} bundleId 
         * @param {File} formFile 
         * @param {string} encryptedFileName 
         * @param {string} signature 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransfersBundleBundleIdAddFilePost: async (bundleId: string, formFile: File, encryptedFileName: string, signature: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('apiTransfersBundleBundleIdAddFilePost', 'bundleId', bundleId)
            // verify required parameter 'formFile' is not null or undefined
            assertParamExists('apiTransfersBundleBundleIdAddFilePost', 'formFile', formFile)
            // verify required parameter 'encryptedFileName' is not null or undefined
            assertParamExists('apiTransfersBundleBundleIdAddFilePost', 'encryptedFileName', encryptedFileName)
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('apiTransfersBundleBundleIdAddFilePost', 'signature', signature)
            const localVarPath = `/api/Transfers/Bundle/{bundleId}/AddFile`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (formFile !== undefined) { 
                localVarFormParams.append('FormFile', formFile as any);
            }
    
            if (encryptedFileName !== undefined) { 
                localVarFormParams.append('EncryptedFileName', encryptedFileName as any);
            }
    
            if (signature !== undefined) { 
                localVarFormParams.append('Signature', signature as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bundleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransfersBundleIdDelete: async (bundleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('apiTransfersBundleIdDelete', 'bundleId', bundleId)
            const localVarPath = `/api/Transfers/{bundleId}`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateBundle} [createBundle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransfersCreateBundlePost: async (createBundle?: CreateBundle, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Transfers/CreateBundle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBundle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} usedPublicKeyId 
         * @param {Array<EncryptedFileDto>} encryptedFiles 
         * @param {Array<EncryptedKeyDto>} encryptedKeys 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransfersPost: async (userId: string, usedPublicKeyId: string, encryptedFiles: Array<EncryptedFileDto>, encryptedKeys: Array<EncryptedKeyDto>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiTransfersPost', 'userId', userId)
            // verify required parameter 'usedPublicKeyId' is not null or undefined
            assertParamExists('apiTransfersPost', 'usedPublicKeyId', usedPublicKeyId)
            // verify required parameter 'encryptedFiles' is not null or undefined
            assertParamExists('apiTransfersPost', 'encryptedFiles', encryptedFiles)
            // verify required parameter 'encryptedKeys' is not null or undefined
            assertParamExists('apiTransfersPost', 'encryptedKeys', encryptedKeys)
            const localVarPath = `/api/Transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (userId !== undefined) { 
                localVarFormParams.append('UserId', userId as any);
            }
    
            if (usedPublicKeyId !== undefined) { 
                localVarFormParams.append('UsedPublicKeyId', usedPublicKeyId as any);
            }
                if (encryptedFiles) {
                encryptedFiles.forEach((element) => {
                    localVarFormParams.append('EncryptedFiles', element as any);
                })
            }

                if (encryptedKeys) {
                encryptedKeys.forEach((element) => {
                    localVarFormParams.append('EncryptedKeys', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransfersApi - functional programming interface
 * @export
 */
export const TransfersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransfersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} bundleId 
         * @param {File} formFile 
         * @param {string} encryptedFileName 
         * @param {string} signature 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransfersBundleBundleIdAddFilePost(bundleId: string, formFile: File, encryptedFileName: string, signature: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransfersBundleBundleIdAddFilePost(bundleId, formFile, encryptedFileName, signature, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} bundleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransfersBundleIdDelete(bundleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransfersBundleIdDelete(bundleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateBundle} [createBundle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransfersCreateBundlePost(createBundle?: CreateBundle, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedBundle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransfersCreateBundlePost(createBundle, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} usedPublicKeyId 
         * @param {Array<EncryptedFileDto>} encryptedFiles 
         * @param {Array<EncryptedKeyDto>} encryptedKeys 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransfersPost(userId: string, usedPublicKeyId: string, encryptedFiles: Array<EncryptedFileDto>, encryptedKeys: Array<EncryptedKeyDto>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransfersPost(userId, usedPublicKeyId, encryptedFiles, encryptedKeys, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransfersApi - factory interface
 * @export
 */
export const TransfersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransfersApiFp(configuration)
    return {
        /**
         * 
         * @param {string} bundleId 
         * @param {File} formFile 
         * @param {string} encryptedFileName 
         * @param {string} signature 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransfersBundleBundleIdAddFilePost(bundleId: string, formFile: File, encryptedFileName: string, signature: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiTransfersBundleBundleIdAddFilePost(bundleId, formFile, encryptedFileName, signature, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bundleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransfersBundleIdDelete(bundleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiTransfersBundleIdDelete(bundleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateBundle} [createBundle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransfersCreateBundlePost(createBundle?: CreateBundle, options?: any): AxiosPromise<CreatedBundle> {
            return localVarFp.apiTransfersCreateBundlePost(createBundle, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} usedPublicKeyId 
         * @param {Array<EncryptedFileDto>} encryptedFiles 
         * @param {Array<EncryptedKeyDto>} encryptedKeys 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransfersPost(userId: string, usedPublicKeyId: string, encryptedFiles: Array<EncryptedFileDto>, encryptedKeys: Array<EncryptedKeyDto>, options?: any): AxiosPromise<void> {
            return localVarFp.apiTransfersPost(userId, usedPublicKeyId, encryptedFiles, encryptedKeys, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransfersApi - object-oriented interface
 * @export
 * @class TransfersApi
 * @extends {BaseAPI}
 */
export class TransfersApi extends BaseAPI {
    /**
     * 
     * @param {string} bundleId 
     * @param {File} formFile 
     * @param {string} encryptedFileName 
     * @param {string} signature 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public apiTransfersBundleBundleIdAddFilePost(bundleId: string, formFile: File, encryptedFileName: string, signature: string, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).apiTransfersBundleBundleIdAddFilePost(bundleId, formFile, encryptedFileName, signature, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bundleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public apiTransfersBundleIdDelete(bundleId: string, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).apiTransfersBundleIdDelete(bundleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateBundle} [createBundle] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public apiTransfersCreateBundlePost(createBundle?: CreateBundle, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).apiTransfersCreateBundlePost(createBundle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {string} usedPublicKeyId 
     * @param {Array<EncryptedFileDto>} encryptedFiles 
     * @param {Array<EncryptedKeyDto>} encryptedKeys 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public apiTransfersPost(userId: string, usedPublicKeyId: string, encryptedFiles: Array<EncryptedFileDto>, encryptedKeys: Array<EncryptedKeyDto>, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).apiTransfersPost(userId, usedPublicKeyId, encryptedFiles, encryptedKeys, options).then((request) => request(this.axios, this.basePath));
    }
}


